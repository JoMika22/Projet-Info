#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h> // Pour la fonction usleep


#define MAX_PERSOS 10
#define MAX_TEAM_NAME 50

// Ajout de macros pour les couleurs
#define RESET "\033[0m"
#define RED "\033[31m"
#define GREEN "\033[32m"
#define YELLOW "\033[33m"
#define BLUE "\033[34m"
#define MAGENTA "\033[35m"
#define CYAN "\033[36m"
#define BOLD "\033[1m"

// Structure d'une attaque sp√©ciale
typedef struct {
    char* nom;
    int cooldown_max;
    int reload;
    char* description;
    int effets; // 0 = d√©g√¢ts, 1 = bouclier
} SpecialAttack;

// Structure d'un personnage
typedef struct {
    char* nom;
    int PV;
    int PVmax;
    int att;
    int def;
    int agi;
    int vit;
    SpecialAttack* special;
    int special_cd;
    int shield_active;
} Perso;

// Structure d'une √©quipe (pour le 2v2)
typedef struct {
    char nom_equipe[MAX_TEAM_NAME];
    Perso** membres;
    int taille;
} Equipe;

// Structure d'un tournoi
typedef struct {
    char nom[50];
    int nb_participants;
    Perso** participants;
    int* points;          // Points pour chaque participant
    int* victoires;       // Nombre de victoires
    int* defaites;        // Nombre de d√©faites
    int* matchs_joues;    // Nouveau: nombre de matchs jou√©s
    int format;           // 1 = poule uniquement (√©limination directe supprim√©e)
} Tournoi;

// Attaques sp√©ciales disponibles
SpecialAttack special_attacks[MAX_PERSOS] = {
    {"√âclair Foudroyant", 3, 5, "D√©charge un √©clair √©lectrique puissant", 0},
    {"Susanoo Protecteur", 3, 6, "Bouclier spirituel (r√©duit d√©g√¢ts)", 1},
    {"Coup de Bicycle", 3, 4, "Frappe acrobatique d√©vastatrice", 0},
    {"Super Splash", 3, 5, "Attaque aquatique massive", 0},
    {"Puissance Ogre", 3, 6, "D√©cha√Æne la force primitive", 0},
    {"Champions League Strike", 3, 4, "Frappe pr√©cise enroul√©e", 0},
    {"Santoryu Ougi", 3, 5, "Triple attaque √©clair", 0},
    {"Bubble Beam", 3, 4, "Canon √† bulles paralysant", 0},
    {"Kamehameha", 3, 7, "Attaque √©nerg√©tique ultime", 0},
    {"Muffin Assault", 3, 3, "Muffins empoisonn√©s", 0}
};

void clear_terminal();
void afficher_barre_sante(int PV, int PVmax);
void animation_combat_epique(const char* attaquant, const char* defenseur);

Perso** creer_persos_disponibles();
void liberer_persos(Perso** persos);
void afficher_menu(Perso** persos);
Equipe* creer_equipe_joueur(Perso** persos);
Equipe* creer_equipe_IA(Perso** persos, int diff);
void afficher_equipe(Equipe* e);
int calculer_degats(Perso* atk, Perso* def);
void appliquer_action(Perso* atk, Perso* def, int action);
int choisir_action_joueur(Perso* p);
int choisir_action_ia(Perso* p);
void tour_de_combat(Equipe* j, Equipe* ia);
void liberer_equipe(Equipe* e);

// Prototypes du mode tournoi
void mode_tournoi(Perso** roster);
Tournoi* creer_tournoi(Perso** roster, Perso* joueur);
void afficher_classement(Tournoi* t);
void simuler_match(Perso* p1, Perso* p2, int* vainqueur, int afficher);
void afficher_resume_match_ia(Perso* p1, Perso* p2, int vainqueur);
void executer_tournoi_poule(Tournoi* t);
void liberer_tournoi(Tournoi* t);
int choisir_nombre_participants();
void organiser_journee_matchs(Tournoi* t, int journee);

// Prototypes menu
int afficher_menu_principal();
void afficher_difficulte();
int choisir_difficulte();

// Fonction pour effacer le terminal
void clear_terminal() {
    printf("\033[H\033[J");
}

// Fonction pour afficher une barre de sant√©
void afficher_barre_sante(int PV, int PVmax) {
    int largeur = 10; // Largeur de la barre (en emojis)
    int remplissage = (PV * largeur) / PVmax;
    printf("[");
    for (int i = 0; i < largeur; i++) {
        if (i < remplissage) printf("üü©"); // Emoji pour la partie remplie
        else printf("‚¨ú"); // Emoji pour la partie vide
    }
    printf("] %d/%d\n", PV, PVmax);
}

// Fonction pour une animation de combat √©pique
void animation_combat_epique(const char* attaquant, const char* defenseur) {
    // D√©finition des couleurs pour les personnages
    const char* color_atk = BOLD BLUE;
    const char* color_def = BOLD RED;

    // Frame 1 - Les personnages se font face
    clear_terminal();
    printf("\n\n");
    printf("    %s    O       %s     O    \n", color_atk, color_def);
    printf("    %s   /|\\      %s    /|\\   \n", color_atk, color_def);
    printf("    %s   / \\      %s    / \\   \n", color_atk, color_def);
    printf("\n");
    printf("    %s%s%s        %s%s%s\n", color_atk, attaquant, RESET, color_def, defenseur, RESET);
    fflush(stdout);
    usleep(700000);

    // Frame 2 - Attaquant avance
    clear_terminal();
    printf("\n\n");
    printf("        %s    O   %s     O    \n", color_atk, color_def);
    printf("        %s   /|\\  %s    /|\\   \n", color_atk, color_def);
    printf("        %s   / \\  %s    / \\   \n", color_atk, color_def);
    printf("\n");
    printf("        %s%s%s    %s%s%s\n", color_atk, attaquant, RESET, color_def, defenseur, RESET);
    fflush(stdout);
    usleep(500000);

    // Frame 3 - Attaquant continue d'avancer
    clear_terminal();
    printf("\n\n");
    printf("            %s    O%s     O    \n", color_atk, color_def);
    printf("            %s   /|\\%s    /|\\   \n", color_atk, color_def);
    printf("            %s   / \\%s    / \\   \n", color_atk, color_def);
    printf("\n");
    printf("            %s%s%s%s%s%s\n", color_atk, attaquant, RESET, color_def, defenseur, RESET);
    fflush(stdout);
    usleep(500000);

    // Frame 4 - Pr√©paration du coup
    clear_terminal();
    printf("\n\n");
    printf("             %s   O %s    O    \n", color_atk, color_def);
    printf("             %s  /|>%s    /|\\   \n", color_atk, color_def);
    printf("             %s  / \\%s    / \\   \n", color_atk, color_def);
    printf("\n");
    printf("             %s%s%s vs %s%s%s\n", color_atk, attaquant, RESET, color_def, defenseur, RESET);
    fflush(stdout);
    usleep(400000);

    // Frame 5 - Impact du coup
    clear_terminal();
    printf("\n\n");
    printf("             %s   O %s    O    \n", color_atk, color_def);
    printf("             %s  /|=>%s   /|\\   \n", color_atk, color_def);
    printf("             %s  / \\%s    / \\   \n", color_atk, color_def);
    printf("\n");
    printf("             %s%s%s vs %s%s%s\n", color_atk, attaquant, RESET, color_def, defenseur, RESET);
    fflush(stdout);
    usleep(300000);

    // Frame 6 - Impact avec effet
    clear_terminal();
    printf("\n\n");
    printf("             %s   O %s    O*   \n", color_atk, color_def);
    printf("             %s  /|=>%s   /|\\   \n", color_atk, color_def);
    printf("             %s  / \\%s    / \\   \n", color_atk, color_def);
    printf("                  %s   *BANG!*%s\n", YELLOW, RESET);
    printf("             %s%s%s vs %s%s%s\n", color_atk, attaquant, RESET, color_def, defenseur, RESET);
    fflush(stdout);
    usleep(200000);

    // Frame 7 - D√©fenseur recule
    clear_terminal();
    printf("\n\n");
    printf("             %s   O %s     O*   \n", color_atk, color_def);
    printf("             %s  /|>%s     /|\\   \n", color_atk, color_def);
    printf("             %s  / \\%s     / \\   \n", color_atk, color_def);
    printf("                   %s  *POW!*%s\n", YELLOW, RESET);
    printf("             %s%s%s vs %s%s%s\n", color_atk, attaquant, RESET, color_def, defenseur, RESET);
    fflush(stdout);
    usleep(200000);

    // Frame 8 - D√©fenseur recule plus
    clear_terminal();
    printf("\n\n");
    printf("             %s   O %s       O*   \n", color_atk, color_def);
    printf("             %s  /|\\%s      /|\\   \n", color_atk, color_def);
    printf("             %s  / \\%s      / \\   \n", color_atk, color_def);
    printf("                     %s*BOOM!*%s\n", YELLOW, RESET);
    printf("             %s%s%s vs %s%s%s\n", color_atk, attaquant, RESET, color_def, defenseur, RESET);
    fflush(stdout);
    usleep(300000);

    // Frame 9 - D√©fenseur √©tourdi
    clear_terminal();
    printf("\n\n");
    printf("             %s   O %s         @_@   \n", color_atk, color_def);
    printf("             %s  /|\\%s        /|\\   \n", color_atk, color_def);
    printf("             %s  / \\%s        / \\   \n", color_atk, color_def);
    printf("                       %s*WHAM!*%s\n", YELLOW, RESET);
    printf("             %s%s%s frappe %s%s%s\n", color_atk, attaquant, RESET, color_def, defenseur, RESET);
    fflush(stdout);
    usleep(400000);

    // Frame 10 - √âtoiles au-dessus du d√©fenseur
    clear_terminal();
    printf("\n\n");
    printf("             %s   O %s      *  *  *  \n", color_atk, color_def);
    printf("             %s  /|\\%s         @_@   \n", color_atk, color_def);
    printf("             %s  / \\%s        / \\   \n", color_atk, color_def);
    fflush(stdout);
}

void afficher_difficulte() {
    clear_terminal(); // Efface le terminal avant d'afficher le menu de difficult√©
    printf(BOLD YELLOW "\nChoisis la difficult√© :\n" RESET);
    printf(BOLD GREEN "1) Facile\n" RESET);
    printf(BOLD CYAN "2) Normal\n" RESET);
    printf(BOLD RED "3) Difficile\n" RESET);
}

int choisir_difficulte() {
    afficher_difficulte();
    int diff; scanf("%d", &diff); getchar();
    if (diff < 1 || diff > 3) {
        printf("Choix invalide. Reessaie.\n");
        return choisir_difficulte();
    }
    return diff;
}

// ===== Impl√©mentation 2v2 =====
Perso** creer_persos_disponibles() {
    Perso** persos = malloc(sizeof(Perso*) * MAX_PERSOS);
    if (!persos) { perror("malloc persos"); exit(1); }
    const char* noms[MAX_PERSOS] = {"Pikachu","Madara","Salah","El Primo","Shrek","CR7","Zoro","Bob l'√©ponge","Goku","Muffin Man"};
    for (int i = 0; i < MAX_PERSOS; i++) {
        persos[i] = malloc(sizeof(Perso));
        persos[i]->nom = strdup(noms[i]);
        persos[i]->PVmax = 800 + i * 100;
        persos[i]->PV = persos[i]->PVmax;
        persos[i]->att = 150 - i * 5;
        persos[i]->def = 80 + i * 2;
        persos[i]->agi = 30 + i * 3;
        persos[i]->vit = 100 + i * 3;
        persos[i]->special = &special_attacks[i];
        persos[i]->special_cd = 0;
        persos[i]->shield_active = 0;
    }
    return persos;
}

void liberer_persos(Perso** persos) {
    for (int i = 0; i < MAX_PERSOS; i++) {
        free(persos[i]->nom);
        free(persos[i]);
    }
    free(persos);
}

void afficher_menu(Perso** persos) {
    clear_terminal(); // Efface le terminal avant d'afficher le menu de choix des personnages
    printf("\n=== CHOIX DES PERSONNAGES ===\n");
    for (int i = 0; i < MAX_PERSOS; i++) {
        printf("%2d) %s  PV:%d ATK:%d DEF:%d VIT:%d\n",
               i+1,
               persos[i]->nom,
               persos[i]->PVmax,
               persos[i]->att,
               persos[i]->def,
               persos[i]->vit);
    }
    printf("============================\n");
}

Equipe* creer_equipe_joueur(Perso** persos) {
    Equipe* e = malloc(sizeof(Equipe));
    printf("Nom de l'√©quipe : ");
    fgets(e->nom_equipe, MAX_TEAM_NAME, stdin);
    e->nom_equipe[strcspn(e->nom_equipe, "\n")] = 0;
    e->taille = 2;
    e->membres = malloc(sizeof(Perso*) * 2);
    afficher_menu(persos);
    for (int i = 0; i < 2; i++) {
        int choix;
        printf("S√©lection perso %d [1-%d] : ", i+1, MAX_PERSOS);
        scanf("%d", &choix); getchar();
        while (choix < 1 || choix > MAX_PERSOS) {
            printf("Choix invalide. Reessayez : ");
            scanf("%d", &choix); getchar();
        }
        e->membres[i] = persos[choix-1];
    }
    return e;
}

Equipe* creer_equipe_IA(Perso** persos, int diff) {
    Equipe* e = malloc(sizeof(Equipe));
    strncpy(e->nom_equipe, "IA", MAX_TEAM_NAME-1);
    e->nom_equipe[MAX_TEAM_NAME-1] = '\0';
    e->taille = 2;
    e->membres = malloc(sizeof(Perso*) * 2);
    int used[MAX_PERSOS] = {0};
    for (int i = 0; i < 2; i++) {
        int r;
        do { r = rand() % MAX_PERSOS; } while (used[r]);
        used[r] = 1;
        // Boost stats selon la difficult√©
        Perso* base = persos[r];
        Perso* clone = malloc(sizeof(Perso));
        *clone = *base;
        double factor = 1.0 + 0.2 * (diff - 1);
        clone->PVmax = (int)(clone->PVmax * factor);
        clone->PV = clone->PVmax;
        clone->att = (int)(clone->att * factor);
        clone->def = (int)(clone->def * factor);
        clone->agi = (int)(clone->agi * factor);
        clone->vit = (int)(clone->vit * factor);
        clone->special_cd = 0;
        clone->shield_active = 0;
        e->membres[i] = clone;
    }
    return e;
}

void afficher_equipe(Equipe* e) {
    printf("\n-- √âquipe %s --\n", e->nom_equipe);
    for (int i = 0; i < e->taille; i++) {
        Perso* p = e->membres[i];
        printf("%s (PV:%d/%d ATK:%d DEF:%d VIT:%d)\n",
               p->nom, p->PV, p->PVmax, p->att, p->def, p->vit);
    }
}

int calculer_degats(Perso* atk, Perso* def) {
    int base = atk->att * 2 - def->def;
    if (base < 1) base = 1;
    if (def->shield_active) base /= 2;
    int var = base / 10;
    int rnd = (rand() % (2*var+1)) - var;
    return base + rnd;
}

void appliquer_action(Perso* atk, Perso* def, int action) {
    atk->shield_active = 0;
    switch(action) {
        case 1: {
            animation_combat_epique(atk->nom, def->nom); // Utilisation de l'animation √©pique
            int dmg = calculer_degats(atk, def);
            def->PV -= dmg;
            if (def->PV < 0) def->PV = 0;
            printf("%s inflige %d d√©g√¢ts √† %s\n", atk->nom, dmg, def->nom);
            break;
        }
        case 2:
            printf("%s active un bouclier\n", atk->nom);
            atk->shield_active = 1;
            break;
        case 3:
            if (atk->special_cd > 0) {
                printf("Sp√©cial indisponible (cd:%d)\n", atk->special_cd);
                return;
            }
            animation_combat_epique(atk->nom, def->nom); // Utilisation de l'animation √©pique
            printf("%s utilise %s\n", atk->nom, atk->special->nom);
            if (atk->special->effets == 1) {
                atk->shield_active = 1;
            } else {
                int dmg2 = calculer_degats(atk, def) * 2;
                def->PV -= dmg2;
                if (def->PV < 0) def->PV = 0;
                printf("Sp√©cial inflige %d d√©g√¢ts √† %s\n", dmg2, def->nom);
            }
            atk->special_cd = atk->special->cooldown_max;
            break;
        default:
            break;
    }
}

int choisir_action_joueur(Perso* p) {
    printf("Actions : 1.Attaque  2.Shield  3.Special (cd:%d) > ", p->special_cd);
    int a;
    scanf("%d", &a);
    getchar();
    if (a == 3 && p->special_cd > 0) {
        printf("Special pas dispo\n");
        return choisir_action_joueur(p);
    }
    return a;
}

int choisir_action_ia(Perso* p) {
    if (p->special_cd == 0 && rand() % 3 == 0) return 3;
    if (rand() % 5 == 0) return 2;
    return 1;
}

void tour_de_combat(Equipe* j, Equipe* ia) {
    clear_terminal(); // Efface le terminal avant de commencer un tour de combat
    int idx_j = 0, idx_ia = 0;
    while (idx_j < j->taille && idx_ia < ia->taille) {
        Perso* pj = j->membres[idx_j];
        Perso* pi = ia->membres[idx_ia];
        printf("\n[Tour] " BOLD GREEN "%s" RESET " PV: ", pj->nom);
        afficher_barre_sante(pj->PV, pj->PVmax);
        printf(BOLD RED "%s" RESET " PV: ", pi->nom);
        afficher_barre_sante(pi->PV, pi->PVmax);

        pj->shield_active = pi->shield_active = 0;
        int act_j = choisir_action_joueur(pj);
        appliquer_action(pj, pi, act_j);
        if (pi->PV == 0) { printf(BOLD RED "%s KO!\n" RESET, pi->nom); idx_ia++; continue; }

        int act_i = choisir_action_ia(pi);
        appliquer_action(pi, pj, act_i);
        if (pj->PV == 0) { printf(BOLD RED "%s KO!\n" RESET, pj->nom); idx_j++; }

        if (pj->special_cd > 0) pj->special_cd--;
        if (pi->special_cd > 0) pi->special_cd--;
    }
    if (idx_j < j->taille) printf("\n" BOLD GREEN "Victoire Joueur!\n" RESET);
    else printf("\n" BOLD RED "Victoire IA!\n" RESET);
}

void liberer_equipe(Equipe* e) {
    for (int i = 0; i < e->taille; i++) {
        free(e->membres[i]);
    }
    free(e->membres);
    free(e);
}

// Mise √† jour du menu principal
int afficher_menu_principal() {
    clear_terminal();
    printf(BOLD YELLOW "=== MENU PRINCIPAL ===\n" RESET);
    printf(BOLD CYAN "1) Combat Classique 2v2\n" RESET);
    printf(BOLD GREEN "2) Mode Tournoi\n" RESET);
    printf(BOLD RED "3) Quitter\n" RESET);
    printf(BOLD YELLOW "======================\n" RESET);
    printf(BOLD MAGENTA "Fais ton choix : " RESET);
    
    int choix;
    if (scanf("%d", &choix) != 1) {
        getchar();
        choix = -1;
    }
    getchar();

    if (choix < 1 || choix > 3) {
        printf("Choix invalide. Reessayez.\n");
        usleep(1000000);
        return afficher_menu_principal();
    }
    return choix;
}

// Fonction pour choisir le nombre de participants
int choisir_nombre_participants() {
    clear_terminal();
    printf(BOLD YELLOW "\n=== FORMAT TOURNOI ===\n" RESET);
    printf(BOLD CYAN "Tournoi √† 4 joueurs\n" RESET);
    printf("\nAppuie sur Entr√©e pour continuer...");
    getchar();
    return 4;  // Force √† 4 participants
}

// Fonction principale du mode tournoi simplifi√©
void mode_tournoi(Perso** roster) {
    clear_terminal();
    printf(BOLD YELLOW "\n=== MODE TOURNOI ===\n" RESET);
    
    // Affichage et s√©lection du personnage
    afficher_menu(roster);
    printf(BOLD CYAN "\nChoisis ton personnage [1-%d] : " RESET, MAX_PERSOS);
    int choix;
    scanf("%d", &choix);
    getchar();
    
    while (choix < 1 || choix > MAX_PERSOS) {
        printf("Choix invalide. R√©essaie : ");
        scanf("%d", &choix);
        getchar();
    }
    
    // Cr√©ation du personnage joueur (simple copie du personnage choisi)
    Perso* perso_joueur = malloc(sizeof(Perso));
    if (!perso_joueur) { perror("malloc perso joueur"); exit(1); }
    
    // Copier le personnage de base
    perso_joueur->nom = strdup(roster[choix-1]->nom);
    perso_joueur->PVmax = roster[choix-1]->PVmax;
    perso_joueur->PV = perso_joueur->PVmax;
    perso_joueur->att = roster[choix-1]->att;
    perso_joueur->def = roster[choix-1]->def;
    perso_joueur->agi = roster[choix-1]->agi;
    perso_joueur->vit = roster[choix-1]->vit;
    perso_joueur->special = roster[choix-1]->special;
    perso_joueur->special_cd = 0;
    perso_joueur->shield_active = 0;
    
    // Cr√©ation et ex√©cution du tournoi
    Tournoi* tournoi = creer_tournoi(roster, perso_joueur);
    
    // Ex√©cution du tournoi
    executer_tournoi_poule(tournoi);
    
    // Nettoyage
    liberer_tournoi(tournoi);
    free(perso_joueur->nom);
    free(perso_joueur);
}

// Fonction pour cr√©er un tournoi
Tournoi* creer_tournoi(Perso** roster, Perso* joueur) {
    Tournoi* t = malloc(sizeof(Tournoi));
    if (!t) { perror("malloc tournoi"); exit(1); }
    
    // Nom du tournoi pr√©d√©fini
    strcpy(t->nom, "Tournoi des Champions");
    
    // Nombre de participants
    t->nb_participants = choisir_nombre_participants();
    
    // Format toujours en poule uniquement
    t->format = 1;
    
    // Allouer la m√©moire pour les participants
    t->participants = malloc(sizeof(Perso*) * t->nb_participants);
    t->points = calloc(t->nb_participants, sizeof(int));
    t->victoires = calloc(t->nb_participants, sizeof(int));
    t->defaites = calloc(t->nb_participants, sizeof(int));
    t->matchs_joues = calloc(t->nb_participants, sizeof(int));
    
    if (!t->participants || !t->points || !t->victoires || !t->defaites || !t->matchs_joues) {
        perror("malloc participants/stats");
        exit(1);
    }
    
    // Le joueur est toujours le premier participant
    t->participants[0] = joueur;
    
    // S√©lectionner les personnages IA al√©atoirement
    int used[MAX_PERSOS] = {0};
    
    // Marquer le personnage du joueur comme utilis√©
    for (int i = 0; i < MAX_PERSOS; i++) {
        if (strcmp(roster[i]->nom, joueur->nom) == 0) {
            used[i] = 1;
            break;
        }
    }
    
    for (int i = 1; i < t->nb_participants; i++) {
        Perso* p = malloc(sizeof(Perso));
        if (!p) { perror("malloc perso tournoi"); exit(1); }
        
        // Choisir un personnage al√©atoire non utilis√© du roster
        int r;
        do {
            r = rand() % MAX_PERSOS;
        } while (used[r]);
        used[r] = 1;
        
        // Copier les stats du personnage de base
        p->nom = strdup(roster[r]->nom);
        p->PVmax = roster[r]->PVmax;
        p->PV = p->PVmax;
        p->att = roster[r]->att;
        p->def = roster[r]->def;
        p->agi = roster[r]->agi;
        p->vit = roster[r]->vit;
        p->vit = roster[r]->vit;
        p->special = roster[r]->special;
        p->special_cd = 0;
        p->shield_active = 0;
        
        t->participants[i] = p;
    }
    
    return t;
}

// Fonction pour afficher le classement
void afficher_classement(Tournoi* t) {
    clear_terminal();
    printf(BOLD YELLOW "\n=== CLASSEMENT DU TOURNOI %s ===\n\n" RESET, t->nom);
    
    // Tableau des indices pour le tri
    int indices[t->nb_participants];
    for (int i = 0; i < t->nb_participants; i++) indices[i] = i;
    
    // Tri par points
    for (int i = 0; i < t->nb_participants - 1; i++) {
        for (int j = 0; j < t->nb_participants - i - 1; j++) {
            if (t->points[indices[j]] < t->points[indices[j + 1]]) {
                int temp = indices[j];
                indices[j] = indices[j + 1];
                indices[j + 1] = temp;
            }
        }
    }
    
    // En-t√™te du tableau
    printf("+-----------------+----+-----+-----+-----+\n");
    printf("|     Joueur      | MJ | Vic | Def | Pts |\n");
    printf("+-----------------+----+-----+-----+-----+\n");
    
    // Contenu du tableau
    for (int i = 0; i < t->nb_participants; i++) {
        int idx = indices[i];
        // Mettre en vert le joueur humain (idx == 0)
        const char* color = (idx == 0) ? BOLD GREEN : "";
        printf("| %s%-15s%s | %2d | %3d | %3d | %3d |\n",
               color,
               t->participants[idx]->nom,
               RESET,
               t->matchs_joues[idx],
               t->victoires[idx],
               t->defaites[idx],
               t->points[idx]);
    }
    printf("+-----------------+----+-----+-----+-----+\n");
}

// Nouvelle fonction pour organiser les matchs d'une journ√©e
void organiser_journee_matchs(Tournoi* t, int journee) {
    int vainqueur;
    
    switch(journee) {
        case 1:  // Premi√®re journ√©e: (0 vs 1) et (2 vs 3)
            simuler_match(t->participants[0], t->participants[1], &vainqueur, 1);
            t->matchs_joues[0]++; t->matchs_joues[1]++;
            if (vainqueur == 0) {
                t->victoires[0]++; t->defaites[1]++;
                t->points[0] += 3;
            } else {
                t->victoires[1]++; t->defaites[0]++;
                t->points[1] += 3;
            }
            
            simuler_match(t->participants[2], t->participants[3], &vainqueur, 0);
            t->matchs_joues[2]++; t->matchs_joues[3]++;
            if (vainqueur == 0) {
                t->victoires[2]++; t->defaites[3]++;
                t->points[2] += 3;
            } else {
                t->victoires[3]++; t->defaites[2]++;
                t->points[3] += 3;
            }
            break;
            
        case 2:  // Deuxi√®me journ√©e: (0 vs 2) et (1 vs 3)
            simuler_match(t->participants[0], t->participants[2], &vainqueur, 1);
            t->matchs_joues[0]++; t->matchs_joues[2]++;
            if (vainqueur == 0) {
                t->victoires[0]++; t->defaites[2]++;
                t->points[0] += 3;
            } else {
                t->victoires[2]++; t->defaites[0]++;
                t->points[2] += 3;
            }
            
            simuler_match(t->participants[1], t->participants[3], &vainqueur, 0);
            t->matchs_joues[1]++; t->matchs_joues[3]++;
            if (vainqueur == 0) {
                t->victoires[1]++; t->defaites[3]++;
                t->points[1] += 3;
            } else {
                t->victoires[3]++; t->defaites[1]++;
                t->points[3] += 3;
            }
            break;
            
        case 3:  // Troisi√®me journ√©e: (0 vs 3) et (1 vs 2)
            simuler_match(t->participants[0], t->participants[3], &vainqueur, 1);
            t->matchs_joues[0]++; t->matchs_joues[3]++;
            if (vainqueur == 0) {
                t->victoires[0]++; t->defaites[3]++;
                t->points[0] += 3;
            } else {
                t->victoires[3]++; t->defaites[0]++;
                t->points[3] += 3;
            }
            
            simuler_match(t->participants[1], t->participants[2], &vainqueur, 0);
            t->matchs_joues[1]++; t->matchs_joues[2]++;
            if (vainqueur == 0) {
                t->victoires[1]++; t->defaites[2]++;
                t->points[1] += 3;
            } else {
                t->victoires[2]++; t->defaites[1]++;
                t->points[2] += 3;
            }
            break;
    }
}

// Modifier la fonction executer_tournoi_poule pour utiliser le nouveau syst√®me
void executer_tournoi_poule(Tournoi* t) {
    clear_terminal();
    printf(BOLD YELLOW "\n=== TOURNOI %s (FORMAT POULE) ===\n" RESET, t->nom);
    printf("\nParticipants :\n");
    
    // Afficher les participants
    for (int i = 0; i < t->nb_participants; i++) {
        printf("%s%s%s%s\n", 
               i == 0 ? BOLD GREEN : "", 
               t->participants[i]->nom,
               i == 0 ? " (TOI)" : "",
               i == 0 ? RESET : "");
    }
    
    printf("\nAppuie sur Entr√©e pour commencer le tournoi...");
    getchar();
    
    // Affichage du classement initial
    afficher_classement(t);
    printf("\nAppuie sur Entr√©e pour commencer les matchs...");
    getchar();
    
    // Boucle principale du tournoi
    int nb_journees = t->nb_participants - 1;  // Nombre de journ√©es n√©cessaires
    
    for (int journee = 1; journee <= nb_journees; journee++) {
        clear_terminal();
        printf(BOLD YELLOW "\n=== JOURN√âE %d ===\n" RESET, journee);
        
        // Organiser les matchs de cette journ√©e
        organiser_journee_matchs(t, journee);
        
        // Apr√®s chaque journ√©e, mettre √† jour le classement
        afficher_classement(t);
        printf("\nAppuie sur Entr√©e pour continuer...");
        getchar();
    }
    
    // Affichage du podium final
    clear_terminal();
    afficher_classement(t);
    printf(BOLD YELLOW "\n=== PODIUM FINAL ===\n" RESET);
    
    int indices[t->nb_participants];
    for (int i = 0; i < t->nb_participants; i++) indices[i] = i;
    
    // Tri pour le podium
    for (int i = 0; i < t->nb_participants - 1; i++) {
        for (int j = 0; j < t->nb_participants - i - 1; j++) {
            if (t->points[indices[j]] < t->points[indices[j + 1]]) {
                int temp = indices[j];
                indices[j] = indices[j + 1];
                indices[j + 1] = temp;
            }
        }
    }
    
    // Affichage du podium visuel
    printf("\n");
    printf("          %süèÜ%s\n", BOLD YELLOW, RESET);
    printf("       %s%s%s\n", BOLD MAGENTA, t->participants[indices[0]]->nom, RESET);
    printf("       %sü•á%s\n", BOLD YELLOW, RESET);
    printf("    _____________\n");
    printf("    |     |     |\n");
    printf(" %s%s%s |     | %s%s%s\n", 
           BOLD CYAN, t->participants[indices[1]]->nom, RESET,
           BOLD GREEN, t->participants[indices[2]]->nom, RESET);
    printf(" %sü•à%s  |     |  %sü•â%s\n", BOLD CYAN, RESET, BOLD GREEN, RESET);
    printf("_____|     |_____\n");
    
    printf(BOLD MAGENTA "\nChampion: %s avec %d points!\n" RESET, 
           t->participants[indices[0]]->nom, t->points[indices[0]]);
    printf(BOLD CYAN "2√®me: %s avec %d points\n" RESET, 
           t->participants[indices[1]]->nom, t->points[indices[1]]);
    printf(BOLD GREEN "3√®me: %s avec %d points\n" RESET, 
           t->participants[indices[2]]->nom, t->points[indices[2]]);
    
    // Ajout du message sp√©cial pour le joueur
    if (indices[0] == 0) {
        printf(BOLD YELLOW "\nF√©licitations ! Tu es champion du tournoi !\n" RESET);
    } else {
        int position = 0;
        for (int i = 0; i < t->nb_participants; i++) {
            if (indices[i] == 0) {
                position = i + 1;
                break;
            }
        }
        printf(BOLD CYAN "\nTu as termin√© √† la %d√®me place.\n" RESET, position);
    }
    
    printf("\nAppuie sur Entr√©e pour revenir au menu principal...");
    getchar();
}

// Fonction pour simuler un match entre deux personnages avec interaction joueur
void simuler_match(Perso* p1, Perso* p2, int* vainqueur, int afficher) {
    p1->PV = p1->PVmax;
    p2->PV = p2->PVmax;
    p1->special_cd = 0;
    p2->special_cd = 0;
    p1->shield_active = 0;
    p2->shield_active = 0;
    
    if (afficher) {
        printf(BOLD YELLOW "\n=== MATCH: %s vs %s ===\n" RESET, p1->nom, p2->nom);
        
        while (p1->PV > 0 && p2->PV > 0) {
            printf("\n[Tour] " BOLD GREEN "%s" RESET " PV: ", p1->nom);
            afficher_barre_sante(p1->PV, p1->PVmax);
            printf(BOLD RED "%s" RESET " PV: ", p2->nom);
            afficher_barre_sante(p2->PV, p2->PVmax);
            
            p1->shield_active = 0;
            int action_j = choisir_action_joueur(p1);
            appliquer_action(p1, p2, action_j);
            
            if (p2->PV <= 0) {
                printf(BOLD GREEN "%s a gagn√©!\n" RESET, p1->nom);
                *vainqueur = 0;
                break;
            }
            
            p2->shield_active = 0;
            int action_ia = choisir_action_ia(p2);
            appliquer_action(p2, p1, action_ia);
            
            if (p1->PV <= 0) {
                printf(BOLD RED "%s a gagn√©!\n" RESET, p2->nom);
                *vainqueur = 1;
                break;
            }
            
            if (p1->special_cd > 0) p1->special_cd--;
            if (p2->special_cd > 0) p2->special_cd--;
        }
    } else {
        // Simulation IA vs IA - code existant pour la simulation automatique
        // ...existing code for IA vs IA simulation...
    }
    
    if (p1->PV > 0 && p2->PV > 0) {
        *vainqueur = (p1->PV > p2->PV) ? 0 : 1;
    }
}

// Fonction pour afficher un r√©sum√© de match entre IA
void afficher_resume_match_ia(Perso* p1, Perso* p2, int vainqueur) {
    printf(BOLD "%s %s" RESET " contre " BOLD "%s" RESET " : ", 
           vainqueur == 0 ? GREEN : "", 
           p1->nom, 
           p2->nom);
    printf("%s a %s\n", 
           vainqueur == 0 ? p1->nom : p2->nom,
           "gagn√©");
}

// Fonction pour lib√©rer la m√©moire du tournoi
void liberer_tournoi(Tournoi* t) {
    // Lib√©rer les personnages IA (pas le joueur qui est √† l'indice 0)
    for (int i = 1; i < t->nb_participants; i++) {
        free(t->participants[i]->nom);
        free(t->participants[i]);
    }
    
    free(t->participants);
    free(t->points);
    free(t->victoires);
    free(t->defaites);
    free(t->matchs_joues);
    free(t);
}

// Fonction principale
int main() {
    srand(time(NULL));
    int choix = 0;
    
    do {
        choix = afficher_menu_principal();
        
        switch(choix) {
            case 1: {
                int diff = choisir_difficulte();
                Perso** persos = creer_persos_disponibles();
                Equipe* joueur = creer_equipe_joueur(persos);
                Equipe* ia = creer_equipe_IA(persos, diff);
                
                afficher_equipe(joueur);
                afficher_equipe(ia);
                
                printf("\nAppuie sur Entr√©e pour commencer le combat...");
                getchar();
                
                tour_de_combat(joueur, ia);
                
                printf("\nAppuie sur Entr√©e pour continuer...");
                getchar();
                
                liberer_equipe(joueur);
                liberer_equipe(ia);
                liberer_persos(persos);
                break;
            }
            case 2: {
                Perso** roster = creer_persos_disponibles();
                mode_tournoi(roster);
                liberer_persos(roster);
                break;
            }
            case 3:
                printf(BOLD GREEN "\nMerci d'avoir jou√©! √Ä bient√¥t!\n" RESET);
                break;
        }
    } while (choix != 3);
    
    return 0;
}
